"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("./common");
var graphql_1 = require("graphql");
var logger_1 = require("./logger");
;
;
;
;
exports.getMongoDbProjection = logger_1.logOnError(function (info, graphQLType) {
    var excludedFields = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        excludedFields[_i - 2] = arguments[_i];
    }
    if (!Object.keys(info).includes('fieldNodes'))
        throw 'First argument of "getMongoDbProjection" must be a GraphQLResolveInfo';
    if (!graphql_1.isType(graphQLType))
        throw 'Second argument of "getMongoDbProjection" must be a GraphQLType';
    var requestedFields = getRequestedFields(info);
    var projection = getProjection.apply(void 0, [requestedFields, graphQLType].concat(excludedFields));
    var resolveFieldsDependencies = getResolveFieldsDependencies(requestedFields, graphQLType);
    return mergeProjectionAndResolveDependencies(projection, resolveFieldsDependencies);
});
function getRequestedFields(info) {
    var selections = common_1.flatten(info.fieldNodes.map(function (_) { return _.selectionSet.selections; }));
    var simplifiedNodes = simplifyNodes({ selections: selections }, info);
    return mergeNodes(simplifiedNodes);
}
exports.getRequestedFields = getRequestedFields;
function simplifyNodes(selectionSetNode, info, dictionary) {
    if (dictionary === void 0) { dictionary = {}; }
    var fieldGraphs = [];
    var fieldGraph = {};
    fieldGraphs.push(fieldGraph);
    selectionSetNode.selections.forEach(function (selectionNode) {
        if (selectionNode.kind === 'FragmentSpread') {
            var fragmentSpreadNode = selectionNode;
            var fragment = buildFragment(fragmentSpreadNode.name.value, info, dictionary);
            fragment.forEach(function (_) { return fieldGraphs.push(_); });
        }
        else if (selectionNode.kind === 'Field') {
            var fieldNode = selectionNode;
            var fieldName = fieldNode.name.value;
            var fieldGraphValue = fieldGraph[fieldName];
            if (fieldGraphValue !== 1) {
                if (!fieldNode.selectionSet) {
                    fieldGraph[fieldName] = 1;
                }
                else {
                    var simplifiedNodes = simplifyNodes(fieldNode.selectionSet, info, dictionary);
                    fieldGraph[fieldName] = (fieldGraphValue || []).concat(simplifiedNodes);
                }
            }
        }
    });
    return fieldGraphs;
}
function buildFragment(fragmentName, info, dictionary) {
    return common_1.cache(dictionary, fragmentName, function () {
        var fragmentDescription = info.fragments[fragmentName];
        return simplifyNodes(fragmentDescription.selectionSet, info, dictionary);
    });
}
function mergeNodes(fieldGraphs) {
    var mergedGraph = {};
    fieldGraphs.forEach(function (fieldGraph) { return Object.keys(fieldGraph).forEach(function (fieldName) {
        var mergedField = mergedGraph[fieldName];
        if (mergedField !== 1) {
            var fieldValue = fieldGraph[fieldName];
            if (fieldValue === 1) {
                mergedGraph[fieldName] = 1;
            }
            else {
                mergedGraph[fieldName] = (mergedField || []).concat(fieldValue);
            }
        }
    }); });
    return Object.keys(mergedGraph).reduce(function (agg, fieldName) {
        var _a;
        var fieldValue = mergedGraph[fieldName];
        return __assign({}, agg, (_a = {}, _a[fieldName] = fieldValue === 1 ? 1 : mergeNodes(fieldValue), _a));
    }, {});
}
function getProjection(fieldNode, graphQLType) {
    var excludedFields = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        excludedFields[_i - 2] = arguments[_i];
    }
    var typeFields = common_1.getTypeFields(graphQLType)();
    return Object.assign.apply(Object, [{}].concat(Object.keys(fieldNode)
        .filter(function (key) { return key !== "__typename"
        && !excludedFields.includes(key)
        && !typeFields[key].resolve; })
        .map(function (key) {
        var _a;
        var field = fieldNode[key];
        if (field === 1) {
            return _a = {}, _a[key] = 1, _a;
        }
        var child = getProjection(field, common_1.getInnerType(typeFields[key].type));
        return common_1.addPrefixToProperties(child, key + ".");
    })));
}
exports.getProjection = getProjection;
function getResolveFieldsDependencies(fieldNode, graphQLType) {
    var typeFields = common_1.getTypeFields(graphQLType)();
    return Object.keys(fieldNode)
        .filter(function (key) { return key !== "__typename"; })
        .reduce(function (agg, key) {
        var field = fieldNode[key];
        var typeField = typeFields[key];
        if (typeField.resolve) {
            if (Array.isArray(typeField.dependencies)) {
                return agg.concat(typeField.dependencies);
            }
            return agg;
        }
        if (field === 1) {
            return agg;
        }
        return agg.concat(getResolveFieldsDependencies(field, common_1.getInnerType(typeField.type)).map(function (f) { return key + '.' + f; }));
    }, []);
}
exports.getResolveFieldsDependencies = getResolveFieldsDependencies;
function mergeProjectionAndResolveDependencies(projection, resolveDependencies) {
    var newProjection = __assign({}, projection);
    var _loop_1 = function () {
        var dependency = resolveDependencies[i];
        var projectionKeys = Object.keys(newProjection);
        if (projectionKeys.includes(dependency)) {
            return "continue";
        }
        if (projectionKeys.some(function (key) { return new RegExp("^" + key + "[.]").test(dependency); })) {
            return "continue";
        }
        var regex = new RegExp("^" + dependency + "[.]");
        projectionKeys
            .filter(function (key) { return regex.test(key); })
            .forEach(function (key) { return delete newProjection[key]; });
        newProjection[dependency] = 1;
    };
    for (var i = 0; i < resolveDependencies.length; i++) {
        _loop_1();
    }
    return newProjection;
}
exports.mergeProjectionAndResolveDependencies = mergeProjectionAndResolveDependencies;
